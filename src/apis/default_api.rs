/*
 * moon-vault-api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`fetch_token_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTokenDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_possible_connections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllPossibleConnectionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_chains`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChainsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_connections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConnectionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_gas_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGasPriceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_quote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetQuoteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_quote_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetQuote0Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_supported_chains`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSupportedChainsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_supported_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSupportedProvidersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tools`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetToolsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`getstatus`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetstatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_quote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostQuoteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_quote_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostQuote0Error {
    UnknownValue(serde_json::Value),
}


pub async fn fetch_token_details(configuration: &configuration::Configuration, chain: &str, token: &str) -> Result<crate::models::ApiResponseTokenDetails, Error<FetchTokenDetailsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/token", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("chain", &chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchTokenDetailsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_tokens(configuration: &configuration::Configuration, ) -> Result<crate::models::ApiResponseTokensResponse, Error<FetchTokensError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/tokens", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchTokensError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_all_possible_connections(configuration: &configuration::Configuration, to_chain: &str, to_token: &str) -> Result<crate::models::ApiResponseTokenInfoByChainId, Error<GetAllPossibleConnectionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/allPossibleConnections", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("toChain", &to_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toToken", &to_token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllPossibleConnectionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_chains(configuration: &configuration::Configuration, optional_chain_types: Option<&str>) -> Result<crate::models::ApiResponseChainsResponse, Error<GetChainsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/chains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = optional_chain_types {
        local_var_req_builder = local_var_req_builder.query(&[("optionalChainTypes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetChainsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_connections(configuration: &configuration::Configuration, from_chain: &str, to_chain: &str, from_token: &str, to_token: &str, chain_types: Option<&str>) -> Result<crate::models::ApiResponseConnectionsResponse, Error<GetConnectionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/connections", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("fromChain", &from_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toChain", &to_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromToken", &from_token.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toToken", &to_token.to_string())]);
    if let Some(ref local_var_str) = chain_types {
        local_var_req_builder = local_var_req_builder.query(&[("chainTypes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetConnectionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_gas_price(configuration: &configuration::Configuration, chain_id: &str) -> Result<crate::models::ApiResponseGasPrice, Error<GetGasPriceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorswap/gasPrice", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("chainId", &chain_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGasPriceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_message(configuration: &configuration::Configuration, ) -> Result<crate::models::PingResponse, Error<GetMessageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ping", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_quote(configuration: &configuration::Configuration, from_chain: &str, to_chain: &str, from_token: &str, to_token: &str, from_amount: &str, from_address: &str, to_address: Option<&str>, order: Option<&str>, slippage: Option<f64>, integrator: Option<&str>, fee: Option<f64>, referrer: Option<&str>, allow_bridges: Option<Vec<String>>, allow_exchanges: Option<Vec<String>>, deny_bridges: Option<Vec<String>>, deny_exchanges: Option<Vec<String>>, prefer_bridges: Option<Vec<String>>, prefer_exchanges: Option<Vec<String>>) -> Result<crate::models::ApiResponseQuote, Error<GetQuoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/quote", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("fromChain", &from_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toChain", &to_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromToken", &from_token.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toToken", &to_token.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromAmount", &from_amount.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromAddress", &from_address.to_string())]);
    if let Some(ref local_var_str) = to_address {
        local_var_req_builder = local_var_req_builder.query(&[("toAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slippage {
        local_var_req_builder = local_var_req_builder.query(&[("slippage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = integrator {
        local_var_req_builder = local_var_req_builder.query(&[("integrator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fee {
        local_var_req_builder = local_var_req_builder.query(&[("fee", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = referrer {
        local_var_req_builder = local_var_req_builder.query(&[("referrer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_bridges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("allowBridges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("allowBridges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = allow_exchanges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("allowExchanges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("allowExchanges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = deny_bridges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("denyBridges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("denyBridges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = deny_exchanges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("denyExchanges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("denyExchanges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = prefer_bridges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("preferBridges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("preferBridges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = prefer_exchanges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("preferExchanges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("preferExchanges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetQuoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_quote_0(configuration: &configuration::Configuration, sell_asset: &str, buy_asset: &str, sell_amount: f64, sender_address: &str, recipient_address: &str, slippage: Option<f64>, limit: Option<f64>, providers: Option<Vec<String>>, preferred_provider: Option<&str>, affiliate_address: Option<&str>, affiliate_basis_points: Option<f64>, allow_smart_contract_recipient: Option<bool>) -> Result<crate::models::ApiResponseQuote, Error<GetQuote0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorswap/quote", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sellAsset", &sell_asset.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("buyAsset", &buy_asset.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sellAmount", &sell_amount.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("senderAddress", &sender_address.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("recipientAddress", &recipient_address.to_string())]);
    if let Some(ref local_var_str) = slippage {
        local_var_req_builder = local_var_req_builder.query(&[("slippage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = providers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("providers".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("providers", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = preferred_provider {
        local_var_req_builder = local_var_req_builder.query(&[("preferredProvider", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate_address {
        local_var_req_builder = local_var_req_builder.query(&[("affiliateAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate_basis_points {
        local_var_req_builder = local_var_req_builder.query(&[("affiliateBasisPoints", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_smart_contract_recipient {
        local_var_req_builder = local_var_req_builder.query(&[("allowSmartContractRecipient", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetQuote0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_supported_chains(configuration: &configuration::Configuration, ) -> Result<crate::models::ApiResponseChainMap, Error<GetSupportedChainsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorswap/chains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSupportedChainsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_supported_providers(configuration: &configuration::Configuration, ) -> Result<crate::models::ApiResponseStringArray, Error<GetSupportedProvidersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorswap/providers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSupportedProvidersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_tools(configuration: &configuration::Configuration, chains: Option<&str>) -> Result<crate::models::ApiResponseToolsResponse, Error<GetToolsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/tools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = chains {
        local_var_req_builder = local_var_req_builder.query(&[("chains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetToolsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn getstatus(configuration: &configuration::Configuration, tx_hash: &str) -> Result<crate::models::ApiResponseStatusResponse, Error<GetstatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("txHash", &tx_hash.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetstatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_quote(configuration: &configuration::Configuration, account_name: &str, authorization: &str, from_chain: &str, to_chain: &str, from_token: &str, to_token: &str, from_amount: &str, from_address: &str, to_address: Option<&str>, order: Option<&str>, slippage: Option<f64>, integrator: Option<&str>, fee: Option<f64>, referrer: Option<&str>, allow_bridges: Option<Vec<String>>, allow_exchanges: Option<Vec<String>>, deny_bridges: Option<Vec<String>>, deny_exchanges: Option<Vec<String>>, prefer_bridges: Option<Vec<String>>, prefer_exchanges: Option<Vec<String>>) -> Result<crate::models::ApiResponsePostQuote, Error<PostQuoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lifi/{accountName}/quote", local_var_configuration.base_path, accountName=crate::apis::urlencode(account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("fromChain", &from_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toChain", &to_chain.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromToken", &from_token.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("toToken", &to_token.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromAmount", &from_amount.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("fromAddress", &from_address.to_string())]);
    if let Some(ref local_var_str) = to_address {
        local_var_req_builder = local_var_req_builder.query(&[("toAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slippage {
        local_var_req_builder = local_var_req_builder.query(&[("slippage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = integrator {
        local_var_req_builder = local_var_req_builder.query(&[("integrator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fee {
        local_var_req_builder = local_var_req_builder.query(&[("fee", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = referrer {
        local_var_req_builder = local_var_req_builder.query(&[("referrer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_bridges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("allowBridges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("allowBridges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = allow_exchanges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("allowExchanges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("allowExchanges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = deny_bridges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("denyBridges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("denyBridges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = deny_exchanges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("denyExchanges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("denyExchanges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = prefer_bridges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("preferBridges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("preferBridges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = prefer_exchanges {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("preferExchanges".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("preferExchanges", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostQuoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_quote_0(configuration: &configuration::Configuration, sell_asset: &str, buy_asset: &str, sell_amount: f64, sender_address: &str, recipient_address: &str, slippage: Option<f64>, limit: Option<f64>, providers: Option<Vec<String>>, preferred_provider: Option<&str>, affiliate_address: Option<&str>, affiliate_basis_points: Option<f64>, allow_smart_contract_recipient: Option<bool>) -> Result<crate::models::ApiResponseQuote, Error<PostQuote0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorswap/{accountName}/quote", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sellAsset", &sell_asset.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("buyAsset", &buy_asset.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sellAmount", &sell_amount.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("senderAddress", &sender_address.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("recipientAddress", &recipient_address.to_string())]);
    if let Some(ref local_var_str) = slippage {
        local_var_req_builder = local_var_req_builder.query(&[("slippage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = providers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("providers".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("providers", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = preferred_provider {
        local_var_req_builder = local_var_req_builder.query(&[("preferredProvider", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate_address {
        local_var_req_builder = local_var_req_builder.query(&[("affiliateAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate_basis_points {
        local_var_req_builder = local_var_req_builder.query(&[("affiliateBasisPoints", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_smart_contract_recipient {
        local_var_req_builder = local_var_req_builder.query(&[("allowSmartContractRecipient", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostQuote0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

